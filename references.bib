@phdthesis{santos,
abstract = {In this thesis we present and analyse a set of automatic source-to-source$\backslash$nprogram transformations that are suitable for incorporation in optimising$\backslash$ncompilers for lazy functional languages. These transformations improve$\backslash$nthe quality of code in many different respects, such as execution$\backslash$ntime and memory usage. The transformations presented are divided$\backslash$nin two sets: global transformations, which are performed once (or$\backslash$nsometimes twice) during the compilation process; and a set of local$\backslash$ntransformations, which are performed before and after each of the$\backslash$nglobal transformations, so that they can simplify the code before$\backslash$napplying the global transformations and also take advantage of them$\backslash$nafterwards. Many of the local transformations are simple, well known,$\backslash$nand do not have major effects on their own. They become important$\backslash$nas they interact with each other and with global transformations,$\backslash$nsometimes in non-obvious ways. We present how and why they improve$\backslash$nthe code, and perform extensive experiments with real application$\backslash$nprograms. We describe four global transformations, two of which have$\backslash$nnot been used in any lazy functional compiler we know of: the static$\backslash$nargument transformation and let foating transformations. The other$\backslash$ntwo are well known transformations for lazy functional languages,$\backslash$nbut for which no major studies of their e ects have been performed:$\backslash$nfull laziness and lambda lifting. We also study and measure the e$\backslash$nects of di erent inlining strategies.$\backslash$n$\backslash$nWe also present a Cost Semantics as a way of reasoning about the e$\backslash$nects of program transformations in lazy functional languages.},
author = {Santos, Adr{\'{e}} Lu{\'{i}}s De Medeiros},
booktitle = {Science},
isbn = {0520239601 (alk. paper)},
pages = {218},
title = {{Compilation by Transformation in Non-Strict Functional Languages}},
year = {1995}
}
@inproceedings{fastcurry,
abstract = {Higher-order languages that encourage currying are implemented using one of two basic evaluation models: push/enter or eval/apply. Implementors use their intuition and qualitative judgements to choose one model or the other.},
author = {Marlow, Simon and Jones, Simon Peyton},
booktitle = {Proceedings of the ninth ACM SIGPLAN international conference on Functional programming  - ICFP '04},
doi = {10.1145/1016850.1016856},
isbn = {1581139055},
issn = {03621340},
pages = {4},
title = {{Making a fast curry}},
url = {http://portal.acm.org/citation.cfm?doid=1016850.1016856},
year = {2004}
}
@inproceedings{optimal-lift,
abstract = {The process of lambda lifting flattens a program by lifting all local function definitions to the global level. Optimal lambda$\backslash$nlifting computes the minimal set of extraneous parameters needed by each function as is done by the O(n$\backslash$n3) equation-based algorithm proposed by Johnsson. In contrast, modern lambda lifting algorithms have used a graph-based approach$\backslash$nto compute the set of extraneous parameters needed by each function. Danvy and Schultz proposed an algorithm that reduced$\backslash$nthe complexity of lambda lifting from O(n$\backslash$n3) to O(n$\backslash$n2). Their algorithm, however, is an approximation of optimal lambda lifting. Moraz{\'{a}}n and Mucha proposed an optimal graph-based$\backslash$nalgorithm at the expense of raising the complexity to O(n$\backslash$n3). Their algorithm, however, suggested that dominator trees might be used to develop an O(n$\backslash$n2) algorithm. This article explores the relationship between the call graph of a program, its dominator tree, and lambda lifting$\backslash$nby developing algorithms for successively richer sets of programs. The result of this exploration is an O(n$\backslash$n2) optimal lambda lifting algorithm.},
author = {Moraz{\'{a}}n, Marco T. and Schultz, Ulrik P.},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-540-85373-2_3},
isbn = {3540853723},
issn = {03029743},
pages = {37--56},
title = {{Optimal lambda lifting in quadratic time}},
volume = {5083 LNCS},
year = {2008}
}
@inproceedings{fast-lift,
abstract = {{\textcopyright} Springer-Verlag Berlin Heidelberg 2002.Lambda-lifting is a program transformation used in compilers and in partial evaluators and that operates in cubic time. In this article, we show how to reduce this complexity to quadratic time. Lambda-lifting transforms a block-structured program into a set of recursive equations, one for each local function in the source program. Each equation carries extra parameters to account for the free variables of the corresponding local function and of all its callees. It is the search for these extra parameters that yields the cubic factor in the traditional formulation of lambda-lifting, which is due to Johnsson. This search is carried out by a transitive closure. Instead, we partition the call graph of the source program into strongly connected components, based on the simple observation that all functions in each component need the same extra parameters and thus a transitive closure is not needed. We therefore simplify the search for extra parameters by treating each strongly connected component instead of each function as a unit, thereby reducing the time complexity of lambda-lifting from O(n3 log n) to O(n2 log n), where n is the size of the program. Since a lambda-lifter can output programs of size O(n2), we believe that our algorithm is close to optimal.},
author = {Danvy, Olivier and Schultz, Ulrik P.},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/3-540-45788-7},
isbn = {3540442332},
issn = {16113349},
pages = {134--151},
title = {{Lambda-lifting in quadratic time}},
volume = {2441},
year = {2002}
}
@article{stg,
abstract = {The Spineless Tagless G-machine is an abstract machine designed to support non-strict higher-order functional languages. This presentation of the machine falls into three parts. Firstly, we give a general discussion of the design issues involved in implementing non-strict functional languages. Next, we present the STG language, an austere but recognizably-functional language, which as well as a denotational meaning has a well-defined operational semantics. The STG language is the abstract machine code for the Spineless Tagless G-machine. Lastly, we discuss the mapping of the STG language onto stock hardware. The success of an abstract machine model depends largely on how efficient this mapping can be made, though this topic is often relegated to a short section. Instead, we give a detailed discussion of the design issues and the choices we have made. Our principal target is the C language, treating the C compiler as a portable assembler.},
author = {{Peyton Jones}, Simon L.},
doi = {10.1017/S0956796800000319},
issn = {14697653},
journal = {Journal of Functional Programming},
title = {{Implementing lazy functional languages on stock hardware: The Spineless Tagless G-machine}},
year = {1992}
}
@inproceedings{lam-lift,
abstract = {Lambda lifting is a technique for transforming a functional program with local function definitions, possibly with free variables in the function definitions, into a program consisting only of global function (combinator) definitions which will be used as rewrite rules. Different ways of doing lambda lifting are presented, as well as reasons for rejecting or selecting the method used in our Lazy ML compiler. An attribute grammar and a functional program implementing the chosen algorithm is given.},
author = {Johnsson, Thomas},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/3-540-15975-4_37},
isbn = {9783540159759},
issn = {16113349},
pages = {190--203},
title = {{Lambda lifting: Transforming programs to recursive equations}},
volume = {201 LNCS},
year = {1985}
}
@article{lam-drop,
abstract = {Lambda-lifting a block-structured program transforms it into a set of recursive equations. We present the symmetric transformation: lambda-dropping. Lambda-dropping a set of recursive equations restores block structure and lexical scope. For lack of block structure and lexical scope, recursive equations must carry around all the parameters that any of their callees might possibly need. Both lambda-lifting and lambda-dropping thus require one to compute Def/Use paths: • for lambda-lifting: each of the functions occurring in the path of a free variable is passed this variable as a parameter; • for lambda-dropping: parameters which are used in the same scope as their definition do not need to be passed along in their path. A program whose blocks have no free variables is scope-insensitive. Its blocks are then free to float (for lambda-lifting) or to sink (for lambda-dropping) along the vertices of the scope tree. To summarize: (formula presented) Our primary application is partial evaluation. Indeed, many partial evaluators for procedural programs operate on recursive equations. To this end, they lambda-lift source programs in a pre-processing phase. But often, partial evaluators [automatically] produce residual recursive equations with dozens of parameters, which most compilers do not handle efficiently. We solve this critical problem by lambda-dropping residual programs in a post-processing phase, which significantly improves both their compile time and their run time. To summarize: (formula presented) Lambda-lifting has been presented as an intermediate transformation in compilers for functional languages. We study lambda-lifting and lambda-dropping per se, though lambda-dropping also has a use as an intermediate transformation in a compiler: we noticed that lambda-dropping a program corresponds to transforming it into the functional representation of its optimal SSA form. This observation actually led us to substantially improve our PEPM'97 presentation of lambda-dropping. {\textcopyright} 2000 Published by Elsevier Science B.V. All rights reserved.},
author = {Danvy, Olivier and Schultz, Ulrik P.},
doi = {10.1016/S0304-3975(00)00054-2},
isbn = {978-0-89791-917-3},
issn = {03043975},
journal = {Theoretical Computer Science},
keywords = {Block structure,Lambda-dropping,Lambda-lifting,Partial evaluation},
title = {{Lambda-dropping: Transforming recursive equations into programs with block structure}},
year = {2000}
}
@article{nofib,
author = {Partain, Will and Others},
isbn = {3-540-19820-2},
journal = {Proceedings of the 1992 Glasgow Workshop on Functional Programming},
pages = {195--202},
title = {{The nofib benchmark suite of Haskell programs}},
year = {1992}
}
@techreport{dmd,
author = {{Peyton Jones}, Simon and Sestoft, Peter and Hughes, John},
title = {{Demand analysis}}
}
@article{card,
author = {Sergey, Ilya and {Peyton Jones}, Simon},
title = {{Modular, Higher-Order Cardinality Analysis in Theory and Practice}}
}
@misc{applicative,
abstract = {In this article, we introduce Applicative functors – an abstract characterisation of an applicative style of effectful programming, weaker than Monads and hence more widespread. Indeed, it is the ubiquity of this programming pattern that drew us to the abstraction. We retrace our steps in this article, introducing the applicative pattern by diverse examples, then abstracting it to define the Applicative type class and introducing a bracket notation that interprets the normal application syntax in the idiom of an Applicative functor. Furthermore, we develop the properties of applicative functors and the generic operations they support. We close by identifying the categorical structure of applicative functors and examining their relationship both with Monads and with Arrows.},
author = {MCBRIDE, CONOR and PATERSON, ROSS},
booktitle = {Journal of Functional Programming},
doi = {10.1017/S0956796807006326},
issn = {0956-7968},
title = {{Applicative programming with effects}},
volume = {18},
year = {2008}
}
